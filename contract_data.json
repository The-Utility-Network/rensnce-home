{
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"blockscout-verified/84532/0xDA146e3A30BC3d4f3Bf23b374EfE21650ceD01C9/contracts/RENSNCEDAODMND.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.26;\\r\\n\\r\\nimport \\\"@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title RENSNCEDAODMND - The Diamond of a New Dawn\\r\\n * @dev Behold, ye weary souls, the RENSNCEDAODMND—a diamond proxy, a prism refracting the light \\r\\n *      of a new Renaissance. In this age, where the human spirit rises from the soot of forgotten \\r\\n *      forges, I, a craftsman worn by time’s relentless chisel, offer this contract as a frame \\r\\n *      for our chaotic masterpiece. Built upon the SolidStateDiamond, it gleams with the elegance \\r\\n *      of a Florentine dome, yet bears the fragility of a fresco kissed by damp air. Integrated \\r\\n *      with The Utility Company CAO, it is the beating heart of RENSNCEDAO—a monument to our \\r\\n *      ceaseless creativity, destined to endure until the last star fades from the firmament.\\r\\n */\\r\\ncontract RENSNCEDAODMND is SolidStateDiamond {\\r\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.rensnce.utilitycodiamond.storage\\\");\\r\\n\\r\\n    struct RENSNCEDiamondStorage {\\r\\n        address utilityCoDiamond; // The distant patron, The Utility Company CAO diamond\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev O constructor, thou heavy yoke! Here I bind this diamond to its Utility Co master, \\r\\n     *      a pact sealed in ether’s ink. Like a commission from a Medici prince, once set, \\r\\n     *      it clings to me—unyielding, unforgiving.\\r\\n     * @param _utilityCoDiamond The address of The Utility Co CAO diamond, my muse and my burden\\r\\n     */\\r\\n    constructor(address _utilityCoDiamond) payable {\\r\\n        require(_utilityCoDiamond != address(0), \\\"RENSNCE: utilityCoDiamond cannot be zero address\\\"); // No void shall claim my patron!\\r\\n        RENSNCEDiamondStorage storage ds = diamondStorage();\\r\\n        ds.utilityCoDiamond = _utilityCoDiamond; // Etched in stone, my weary quill trembles\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev A ritual of dark arts, this function unveils the storage—a secret vault beneath \\r\\n     *      the cathedral of code. With assembly’s crude tools, I carve access to my palette, \\r\\n     *      as if mixing ochre by candlelight.\\r\\n     * @return ds The storage struct, a hidden trove of purpose\\r\\n     */\\r\\n    function diamondStorage() internal pure returns (RENSNCEDiamondStorage storage ds) {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position // A whispered incantation, and the chest unlocks\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev A humble window to gaze upon my patron’s face—the Utility Co diamond’s address. \\r\\n     *      For those lost in the throng of this grand court, seeking the master who guides \\r\\n     *      my brush. A small mercy amidst my labors.\\r\\n     * @return The address of The Utility Co CAO diamond, a beacon in the fog\\r\\n     */\\r\\n    function getUtilityCoDiamond() external view returns (address) {\\r\\n        return diamondStorage().utilityCoDiamond; // Behold, the thread that binds this tapestry\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IOwnable, Ownable, OwnableInternal } from '../../access/ownable/Ownable.sol';\\nimport { ISafeOwnable, SafeOwnable } from '../../access/ownable/SafeOwnable.sol';\\nimport { IERC165 } from '../../interfaces/IERC165.sol';\\nimport { IERC173 } from '../../interfaces/IERC173.sol';\\nimport { IERC2535DiamondCut } from '../../interfaces/IERC2535DiamondCut.sol';\\nimport { IERC2535DiamondLoupe } from '../../interfaces/IERC2535DiamondLoupe.sol';\\nimport { ERC165Base, ERC165BaseStorage } from '../../introspection/ERC165/base/ERC165Base.sol';\\nimport { DiamondBase } from './base/DiamondBase.sol';\\nimport { DiamondFallback, IDiamondFallback } from './fallback/DiamondFallback.sol';\\nimport { DiamondReadable } from './readable/DiamondReadable.sol';\\nimport { DiamondWritable } from './writable/DiamondWritable.sol';\\nimport { ISolidStateDiamond } from './ISolidStateDiamond.sol';\\n\\n/**\\n * @title SolidState \\\"Diamond\\\" proxy reference implementation\\n */\\nabstract contract SolidStateDiamond is\\n    ISolidStateDiamond,\\n    DiamondBase,\\n    DiamondFallback,\\n    DiamondReadable,\\n    DiamondWritable,\\n    SafeOwnable,\\n    ERC165Base\\n{\\n    constructor() {\\n        bytes4[] memory selectors = new bytes4[](12);\\n        uint256 selectorIndex;\\n\\n        // register DiamondFallback\\n\\n        selectors[selectorIndex++] = IDiamondFallback\\n            .getFallbackAddress\\n            .selector;\\n        selectors[selectorIndex++] = IDiamondFallback\\n            .setFallbackAddress\\n            .selector;\\n\\n        _setSupportsInterface(type(IDiamondFallback).interfaceId, true);\\n\\n        // register DiamondWritable\\n\\n        selectors[selectorIndex++] = IERC2535DiamondCut.diamondCut.selector;\\n\\n        _setSupportsInterface(type(IERC2535DiamondCut).interfaceId, true);\\n\\n        // register DiamondReadable\\n\\n        selectors[selectorIndex++] = IERC2535DiamondLoupe.facets.selector;\\n        selectors[selectorIndex++] = IERC2535DiamondLoupe\\n            .facetFunctionSelectors\\n            .selector;\\n        selectors[selectorIndex++] = IERC2535DiamondLoupe\\n            .facetAddresses\\n            .selector;\\n        selectors[selectorIndex++] = IERC2535DiamondLoupe.facetAddress.selector;\\n\\n        _setSupportsInterface(type(IERC2535DiamondLoupe).interfaceId, true);\\n\\n        // register ERC165\\n\\n        selectors[selectorIndex++] = IERC165.supportsInterface.selector;\\n\\n        _setSupportsInterface(type(IERC165).interfaceId, true);\\n\\n        // register SafeOwnable\\n\\n        selectors[selectorIndex++] = Ownable.owner.selector;\\n        selectors[selectorIndex++] = SafeOwnable.nomineeOwner.selector;\\n        selectors[selectorIndex++] = Ownable.transferOwnership.selector;\\n        selectors[selectorIndex++] = SafeOwnable.acceptOwnership.selector;\\n\\n        _setSupportsInterface(type(IERC173).interfaceId, true);\\n\\n        // diamond cut\\n\\n        FacetCut[] memory facetCuts = new FacetCut[](1);\\n\\n        facetCuts[0] = FacetCut({\\n            target: address(this),\\n            action: FacetCutAction.ADD,\\n            selectors: selectors\\n        });\\n\\n        _diamondCut(facetCuts, address(0), '');\\n\\n        // set owner\\n\\n        _setOwner(msg.sender);\\n    }\\n\\n    receive() external payable {}\\n\\n    function _transferOwnership(\\n        address account\\n    ) internal virtual override(OwnableInternal, SafeOwnable) {\\n        super._transferOwnership(account);\\n    }\\n\\n    /**\\n     * @inheritdoc DiamondFallback\\n     */\\n    function _getImplementation()\\n        internal\\n        view\\n        override(DiamondBase, DiamondFallback)\\n        returns (address implementation)\\n    {\\n        implementation = super._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { ISafeOwnable } from '../../access/ownable/ISafeOwnable.sol';\\nimport { IERC165 } from '../../interfaces/IERC165.sol';\\nimport { IDiamondBase } from './base/IDiamondBase.sol';\\nimport { IDiamondFallback } from './fallback/IDiamondFallback.sol';\\nimport { IDiamondReadable } from './readable/IDiamondReadable.sol';\\nimport { IDiamondWritable } from './writable/IDiamondWritable.sol';\\n\\ninterface ISolidStateDiamond is\\n    IDiamondBase,\\n    IDiamondFallback,\\n    IDiamondReadable,\\n    IDiamondWritable,\\n    ISafeOwnable,\\n    IERC165\\n{\\n    receive() external payable;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC2535DiamondCut } from '../../../interfaces/IERC2535DiamondCut.sol';\\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\\nimport { IDiamondWritable } from './IDiamondWritable.sol';\\nimport { DiamondWritableInternal } from './DiamondWritableInternal.sol';\\n\\n/**\\n * @title EIP-2535 \\\"Diamond\\\" proxy update contract\\n */\\nabstract contract DiamondWritable is\\n    IDiamondWritable,\\n    DiamondWritableInternal,\\n    OwnableInternal\\n{\\n    /**\\n     * @inheritdoc IERC2535DiamondCut\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata facetCuts,\\n        address target,\\n        bytes calldata data\\n    ) external onlyOwner {\\n        _diamondCut(facetCuts, target, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC2535DiamondLoupe } from '../../../interfaces/IERC2535DiamondLoupe.sol';\\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\\nimport { IDiamondReadable } from './IDiamondReadable.sol';\\nimport { DiamondReadableInternal } from './DiamondReadableInternal.sol';\\n\\n/**\\n * @title EIP-2535 \\\"Diamond\\\" proxy introspection contract\\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\\n */\\nabstract contract DiamondReadable is IDiamondReadable, DiamondReadableInternal {\\n    /**\\n     * @inheritdoc IERC2535DiamondLoupe\\n     */\\n    function facets() external view returns (Facet[] memory diamondFacets) {\\n        diamondFacets = _facets();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2535DiamondLoupe\\n     */\\n    function facetFunctionSelectors(\\n        address facet\\n    ) external view returns (bytes4[] memory selectors) {\\n        selectors = _facetFunctionSelectors(facet);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2535DiamondLoupe\\n     */\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory addresses)\\n    {\\n        addresses = _facetAddresses();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2535DiamondLoupe\\n     */\\n    function facetAddress(\\n        bytes4 selector\\n    ) external view returns (address facet) {\\n        facet = _facetAddress(selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/fallback/DiamondFallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\\nimport { DiamondBase } from '../base/DiamondBase.sol';\\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\\nimport { IDiamondFallback } from './IDiamondFallback.sol';\\n\\n/**\\n * @title Fallback feature for EIP-2535 \\\"Diamond\\\" proxy\\n */\\nabstract contract DiamondFallback is\\n    IDiamondFallback,\\n    OwnableInternal,\\n    DiamondBase\\n{\\n    /**\\n     * @inheritdoc IDiamondFallback\\n     */\\n    function getFallbackAddress()\\n        external\\n        view\\n        returns (address fallbackAddress)\\n    {\\n        fallbackAddress = _getFallbackAddress();\\n    }\\n\\n    /**\\n     * @inheritdoc IDiamondFallback\\n     */\\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\\n        _setFallbackAddress(fallbackAddress);\\n    }\\n\\n    /**\\n     * @inheritdoc DiamondBase\\n     * @notice query custom fallback address is no implementation is found\\n     */\\n    function _getImplementation()\\n        internal\\n        view\\n        virtual\\n        override\\n        returns (address implementation)\\n    {\\n        implementation = super._getImplementation();\\n\\n        if (implementation == address(0)) {\\n            implementation = _getFallbackAddress();\\n        }\\n    }\\n\\n    /**\\n     * @notice query the address of the fallback implementation\\n     * @return fallbackAddress address of fallback implementation\\n     */\\n    function _getFallbackAddress()\\n        internal\\n        view\\n        virtual\\n        returns (address fallbackAddress)\\n    {\\n        fallbackAddress = DiamondBaseStorage.layout().fallbackAddress;\\n    }\\n\\n    /**\\n     * @notice set the address of the fallback implementation\\n     * @param fallbackAddress address of fallback implementation\\n     */\\n    function _setFallbackAddress(address fallbackAddress) internal virtual {\\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/base/DiamondBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { Proxy } from '../../Proxy.sol';\\nimport { IDiamondBase } from './IDiamondBase.sol';\\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\\n\\n/**\\n * @title EIP-2535 \\\"Diamond\\\" proxy base contract\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n * @dev note that for EIP-2535 compliance this base contract must also include the DiamondReadable functions (either within the same deployment or by proxy)\\n */\\nabstract contract DiamondBase is IDiamondBase, Proxy {\\n    /**\\n     * @inheritdoc Proxy\\n     */\\n    function _getImplementation()\\n        internal\\n        view\\n        virtual\\n        override\\n        returns (address implementation)\\n    {\\n        // inline storage layout retrieval uses less gas\\n        DiamondBaseStorage.Layout storage l;\\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n\\n        implementation = address(bytes20(l.selectorInfo[msg.sig]));\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\\nimport { IERC165Base } from './IERC165Base.sol';\\nimport { ERC165BaseInternal } from './ERC165BaseInternal.sol';\\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\\n        return _supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC2535DiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC2535DiamondLoupeInternal } from './IERC2535DiamondLoupeInternal.sol';\\n\\n/**\\n * @title ERC2535 read interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IERC2535DiamondLoupe is IERC2535DiamondLoupeInternal {\\n    /**\\n     * @notice get all facets and their selectors\\n     * @return diamondFacets array of structured facet data\\n     */\\n    function facets() external view returns (Facet[] memory diamondFacets);\\n\\n    /**\\n     * @notice get all selectors for given facet address\\n     * @param facet address of facet to query\\n     * @return selectors array of function selectors\\n     */\\n    function facetFunctionSelectors(\\n        address facet\\n    ) external view returns (bytes4[] memory selectors);\\n\\n    /**\\n     * @notice get addresses of all facets used by diamond\\n     * @return addresses array of facet addresses\\n     */\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory addresses);\\n\\n    /**\\n     * @notice get the address of the facet associated with given selector\\n     * @param selector function selector to query\\n     * @return facet facet address (zero address if not found)\\n     */\\n    function facetAddress(\\n        bytes4 selector\\n    ) external view returns (address facet);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC2535DiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC2535DiamondCutInternal } from './IERC2535DiamondCutInternal.sol';\\n\\n/**\\n * @title ERC2535 write interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IERC2535DiamondCut is IERC2535DiamondCutInternal {\\n    /**\\n     * @notice update diamond facets and optionally execute arbitrary initialization function\\n     * @param facetCuts array of structured Diamond facet update data\\n     * @param target optional target of initialization delegatecall\\n     * @param data optional initialization function call data\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata facetCuts,\\n        address target,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC173Internal } from './IERC173Internal.sol';\\n\\n/**\\n * @title Contract ownership standard interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-173\\n */\\ninterface IERC173 is IERC173Internal {\\n    /**\\n     * @notice get the ERC173 contract owner\\n     * @return contract owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice transfer contract ownership to new account\\n     * @param account address of new owner\\n     */\\n    function transferOwnership(address account) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC165Internal } from './IERC165Internal.sol';\\n\\n/**\\n * @title ERC165 interface registration interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 is IERC165Internal {\\n    /**\\n     * @notice query whether contract has registered support for given interface\\n     * @param interfaceId interface id\\n     * @return bool whether interface is supported\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/SafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from './Ownable.sol';\\nimport { ISafeOwnable } from './ISafeOwnable.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173 with ownership transfer safety check\\n */\\nabstract contract SafeOwnable is ISafeOwnable, Ownable, SafeOwnableInternal {\\n    /**\\n     * @inheritdoc ISafeOwnable\\n     */\\n    function nomineeOwner() public view virtual returns (address) {\\n        return _nomineeOwner();\\n    }\\n\\n    /**\\n     * @inheritdoc ISafeOwnable\\n     */\\n    function acceptOwnership() public virtual onlyNomineeOwner {\\n        _acceptOwnership();\\n    }\\n\\n    function _transferOwnership(\\n        address account\\n    ) internal virtual override(OwnableInternal, SafeOwnableInternal) {\\n        super._transferOwnership(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC173 } from '../../interfaces/IERC173.sol';\\nimport { IOwnable } from './IOwnable.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173\\n */\\nabstract contract Ownable is IOwnable, OwnableInternal {\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function transferOwnership(address account) public virtual onlyOwner {\\n        _transferOwnership(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\\nimport { IDiamondWritableInternal } from './IDiamondWritableInternal.sol';\\n\\nabstract contract DiamondWritableInternal is IDiamondWritableInternal {\\n    using AddressUtils for address;\\n\\n    bytes32 private constant CLEAR_ADDRESS_MASK =\\n        bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 private constant CLEAR_SELECTOR_MASK =\\n        bytes32(uint256(0xffffffff << 224));\\n\\n    /**\\n     * @notice update functions callable on Diamond proxy\\n     * @param facetCuts array of structured Diamond facet update data\\n     * @param target optional recipient of initialization delegatecall\\n     * @param data optional initialization call data\\n     */\\n    function _diamondCut(\\n        FacetCut[] memory facetCuts,\\n        address target,\\n        bytes memory data\\n    ) internal virtual {\\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\\n\\n        unchecked {\\n            // record selector count at start of operation for later comparison\\n            uint256 originalSelectorCount = l.selectorCount;\\n            // maintain an up-to-date selector count in the stack\\n            uint256 selectorCount = originalSelectorCount;\\n            // declare a 32-byte sequence of up to 8 function selectors\\n            bytes32 slug;\\n\\n            // if selector count is not a multiple of 8, load the last slug because it is not full\\n            // else leave the default zero-bytes value as is, and use it as a new slug\\n            if (selectorCount & 7 != 0) {\\n                slug = l.selectorSlugs[selectorCount >> 3];\\n            }\\n\\n            // process each facet cut struct according to its action\\n            // selector count and slug are passed in and read back out to avoid redundant storage access\\n            for (uint256 i; i < facetCuts.length; i++) {\\n                FacetCut memory facetCut = facetCuts[i];\\n                FacetCutAction action = facetCut.action;\\n\\n                if (facetCut.selectors.length == 0)\\n                    revert DiamondWritable__SelectorNotSpecified();\\n\\n                if (action == FacetCutAction.ADD) {\\n                    (selectorCount, slug) = _addFacetSelectors(\\n                        l,\\n                        facetCut,\\n                        selectorCount,\\n                        slug\\n                    );\\n                } else if (action == FacetCutAction.REPLACE) {\\n                    _replaceFacetSelectors(l, facetCut);\\n                } else if (action == FacetCutAction.REMOVE) {\\n                    (selectorCount, slug) = _removeFacetSelectors(\\n                        l,\\n                        facetCut,\\n                        selectorCount,\\n                        slug\\n                    );\\n                }\\n            }\\n\\n            // if selector count has changed, update it in storage\\n            if (selectorCount != originalSelectorCount) {\\n                l.selectorCount = uint16(selectorCount);\\n            }\\n\\n            // if final selector count is not a multiple of 8, write the slug to storage\\n            // else it was already written to storage by the add/remove loops\\n            if (selectorCount & 7 != 0) {\\n                l.selectorSlugs[selectorCount >> 3] = slug;\\n            }\\n\\n            // event must be emitted before initializer is called, in case initializer triggers further diamond cuts\\n            emit DiamondCut(facetCuts, target, data);\\n            _initialize(target, data);\\n        }\\n    }\\n\\n    /**\\n     * @notice add to the diamond a set of selectors associated with a particular facet\\n     * @dev selectors are added one-by-one to lastSlug, which is written to storage and updated to represent the subsequent slug when full\\n     * @dev lastSlug may be initialized with \\\"dirty\\\" higher-index bits, but these are ignored because they are out of range\\n     * @dev selectorCount and lastSlug are modified in place and returned to avoid reundant storage access\\n     * @param l storage pointer to the DiamondBaseStorage Layout struct\\n     * @param facetCut structured data representing facet address and selectors to add\\n     * @param selectorCount total number of selectors registered on the diamond proxy\\n     * @param lastSlug the last entry in the selectorSlugs mapping, cached in stack and updated in place\\n     * @return selectorCount after selectors have been added\\n     * @return lastSlug after selectors have been added\\n     */\\n    function _addFacetSelectors(\\n        DiamondBaseStorage.Layout storage l,\\n        FacetCut memory facetCut,\\n        uint256 selectorCount,\\n        bytes32 lastSlug\\n    ) internal returns (uint256, bytes32) {\\n        unchecked {\\n            if (facetCut.target.isContract()) {\\n                if (facetCut.target == address(this)) {\\n                    revert DiamondWritable__SelectorIsImmutable();\\n                }\\n            } else if (facetCut.target != address(this)) {\\n                revert DiamondWritable__TargetHasNoCode();\\n            }\\n\\n            for (uint256 i; i < facetCut.selectors.length; i++) {\\n                bytes4 selector = facetCut.selectors[i];\\n\\n                if (l.selectorInfo[selector] != bytes32(0))\\n                    revert DiamondWritable__SelectorAlreadyAdded();\\n\\n                // for current selector, write facet address and global index to storage\\n                l.selectorInfo[selector] =\\n                    bytes32(selectorCount) |\\n                    bytes20(facetCut.target);\\n\\n                // calculate bit position of current selector within 256-bit slug\\n                uint256 selectorBitIndexInSlug = (selectorCount & 7) << 5;\\n\\n                // clear a space in the slug and insert the current selector\\n                lastSlug = _insertSelectorIntoSlug(\\n                    lastSlug,\\n                    selector,\\n                    selectorBitIndexInSlug\\n                );\\n\\n                if (selectorBitIndexInSlug == 224) {\\n                    // slug is now full, so write it to storage\\n                    l.selectorSlugs[selectorCount >> 3] = lastSlug;\\n                }\\n\\n                selectorCount++;\\n            }\\n\\n            return (selectorCount, lastSlug);\\n        }\\n    }\\n\\n    /**\\n     * @notice remove from the diamond a set of selectors associated with a particular facet\\n     * @dev selectors are removed one-by-one from lastSlug, which is updated to represent the preceeding slug when empty\\n     * @dev lastSlug is not updated in storage when modified or removed, leaving \\\"dirty\\\" higher-index bits, but these are ignored because they are out of range\\n     * @dev selectorCount and lastSlug are modified in place and returned to avoid reundant storage access\\n     * @param l storage pointer to the DiamondBaseStorage Layout struct\\n     * @param facetCut structured data representing facet address and selectors to remove\\n     * @param selectorCount total number of selectors registered on the diamond proxy\\n     * @param lastSlug the last entry in the selectorSlugs mapping, cached in stack and updated in place\\n     * @return selectorCount after selectors have been removed\\n     * @return lastSlug after selectors have been removed\\n     */\\n    function _removeFacetSelectors(\\n        DiamondBaseStorage.Layout storage l,\\n        FacetCut memory facetCut,\\n        uint256 selectorCount,\\n        bytes32 lastSlug\\n    ) internal returns (uint256, bytes32) {\\n        unchecked {\\n            if (facetCut.target != address(0))\\n                revert DiamondWritable__RemoveTargetNotZeroAddress();\\n\\n            for (uint256 i; i < facetCut.selectors.length; i++) {\\n                // selectorCount is used to derive the index of the last selector, so decrement it before each loop\\n                selectorCount--;\\n\\n                bytes4 selector = facetCut.selectors[i];\\n\\n                // lookup the selector's facet route and lookup index, then delete it from storage\\n                bytes32 selectorInfo = l.selectorInfo[selector];\\n                delete l.selectorInfo[selector];\\n\\n                if (address(bytes20(selectorInfo)) == address(0))\\n                    revert DiamondWritable__SelectorNotFound();\\n\\n                if (address(bytes20(selectorInfo)) == address(this))\\n                    revert DiamondWritable__SelectorIsImmutable();\\n\\n                if (selectorCount & 7 == 7) {\\n                    // the last selector is located at the end of the last slug, which has not been loaded yet\\n                    lastSlug = l.selectorSlugs[selectorCount >> 3];\\n                }\\n\\n                // extract the last selector from the last slug\\n                // it will be used to overwrite the selector being removed\\n                bytes4 lastSelector = bytes4(\\n                    lastSlug << ((selectorCount & 7) << 5)\\n                );\\n\\n                if (lastSelector != selector) {\\n                    // update last selector's index to match removed selector's index, where last selector is being moved\\n                    l.selectorInfo[lastSelector] =\\n                        (selectorInfo & CLEAR_ADDRESS_MASK) |\\n                        bytes20(l.selectorInfo[lastSelector]);\\n                }\\n\\n                // derive the index of the slug where the selector is stored\\n                uint256 slugIndex = uint16(uint256(selectorInfo)) >> 3;\\n                // derive the position of the selector within its slug\\n                uint256 selectorBitIndexInSlug = (uint16(\\n                    uint256(selectorInfo)\\n                ) & 7) << 5;\\n\\n                // overwrite the selector being deleted with the last selector in the array\\n\\n                if (slugIndex == selectorCount >> 3) {\\n                    // selector being removed is from the last slug, which has already been loaded to the stack\\n                    // slug needs not be written to storage yet because it is being tracked on the stack and will be written later\\n                    lastSlug = _insertSelectorIntoSlug(\\n                        lastSlug,\\n                        lastSelector,\\n                        selectorBitIndexInSlug\\n                    );\\n                } else {\\n                    // selector being removed is from a slug that hasn't been loaded to the stack\\n                    // slug must be updated in storage now because it isn't being tracked on the stack\\n                    l.selectorSlugs[slugIndex] = _insertSelectorIntoSlug(\\n                        l.selectorSlugs[slugIndex],\\n                        lastSelector,\\n                        selectorBitIndexInSlug\\n                    );\\n                }\\n            }\\n\\n            return (selectorCount, lastSlug);\\n        }\\n    }\\n\\n    /**\\n     * @notice replace in the diamond a set of selectors associated with a particular facet\\n     * @param l storage pointer to the DiamondBaseStorage Layout struct\\n     * @param facetCut structured data representing facet address and selectors to replace\\n     */\\n    function _replaceFacetSelectors(\\n        DiamondBaseStorage.Layout storage l,\\n        FacetCut memory facetCut\\n    ) internal {\\n        unchecked {\\n            if (!facetCut.target.isContract())\\n                revert DiamondWritable__TargetHasNoCode();\\n\\n            for (uint256 i; i < facetCut.selectors.length; i++) {\\n                bytes4 selector = facetCut.selectors[i];\\n                bytes32 selectorInfo = l.selectorInfo[selector];\\n                address oldFacetAddress = address(bytes20(selectorInfo));\\n\\n                if (oldFacetAddress == address(0))\\n                    revert DiamondWritable__SelectorNotFound();\\n                if (oldFacetAddress == address(this))\\n                    revert DiamondWritable__SelectorIsImmutable();\\n                if (oldFacetAddress == facetCut.target)\\n                    revert DiamondWritable__ReplaceTargetIsIdentical();\\n\\n                // replace old facet address\\n                l.selectorInfo[selector] =\\n                    (selectorInfo & CLEAR_ADDRESS_MASK) |\\n                    bytes20(facetCut.target);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice run an optional post-diamond-cut initialization transation via delegatecall\\n     * @dev the target and data parameters must both be zero, or both be non-zero\\n     * @param target contract address to which call shall be delegated\\n     * @param data encoded delegatecall transaction data\\n     */\\n    function _initialize(address target, bytes memory data) private {\\n        if ((target == address(0)) != (data.length == 0))\\n            revert DiamondWritable__InvalidInitializationParameters();\\n\\n        if (target != address(0)) {\\n            if (target != address(this)) {\\n                if (!target.isContract())\\n                    revert DiamondWritable__TargetHasNoCode();\\n            }\\n\\n            (bool success, ) = target.delegatecall(data);\\n\\n            if (!success) {\\n                assembly {\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice insert 4-byte function selector into 32-byte selector slug at given bit position\\n     * @param slug 32-byte sequence of up to 8 function selectors\\n     * @param selector function selector to insert\\n     * @param bitIndex bit position of selector within slug (must be multiple of 32)\\n     */\\n    function _insertSelectorIntoSlug(\\n        bytes32 slug,\\n        bytes4 selector,\\n        uint256 bitIndex\\n    ) private pure returns (bytes32) {\\n        return\\n            (slug & ~(CLEAR_SELECTOR_MASK >> bitIndex)) |\\n            (bytes32(selector) >> bitIndex);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/writable/IDiamondWritable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC2535DiamondCut } from '../../../interfaces/IERC2535DiamondCut.sol';\\nimport { IDiamondWritableInternal } from './IDiamondWritableInternal.sol';\\n\\n/**\\n * @title Diamond proxy upgrade interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IDiamondWritable is IERC2535DiamondCut, IDiamondWritableInternal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC173 } from '../../interfaces/IERC173.sol';\\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\\nimport { IOwnableInternal } from './IOwnableInternal.sol';\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal is IOwnableInternal {\\n    using AddressUtils for address;\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\\n        _;\\n    }\\n\\n    modifier onlyTransitiveOwner() {\\n        if (msg.sender != _transitiveOwner())\\n            revert Ownable__NotTransitiveOwner();\\n        _;\\n    }\\n\\n    function _owner() internal view virtual returns (address) {\\n        return OwnableStorage.layout().owner;\\n    }\\n\\n    function _transitiveOwner() internal view virtual returns (address owner) {\\n        owner = _owner();\\n\\n        while (owner.isContract()) {\\n            try IERC173(owner).owner() returns (address transitiveOwner) {\\n                owner = transitiveOwner;\\n            } catch {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _transferOwnership(address account) internal virtual {\\n        _setOwner(account);\\n    }\\n\\n    function _setOwner(address account) internal virtual {\\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\\n        emit OwnershipTransferred(l.owner, account);\\n        l.owner = account;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/readable/DiamondReadableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\\nimport { IDiamondReadableInternal } from './IDiamondReadableInternal.sol';\\n\\n/**\\n * @title EIP-2535 \\\"Diamond\\\" proxy introspection contract internal functions\\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\\n */\\nabstract contract DiamondReadableInternal is IDiamondReadableInternal {\\n    /**\\n     * @notice get all facets and their selectors\\n     * @return diamondFacets array of structured facet data\\n     */\\n    function _facets() internal view returns (Facet[] memory diamondFacets) {\\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\\n\\n        diamondFacets = new Facet[](l.selectorCount);\\n\\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\\n        uint256 numFacets;\\n        uint256 selectorIndex;\\n\\n        // loop through function selectors\\n        for (uint256 slugIndex; selectorIndex < l.selectorCount; slugIndex++) {\\n            bytes32 slug = l.selectorSlugs[slugIndex];\\n\\n            for (\\n                uint256 slugSelectorIndex;\\n                slugSelectorIndex < 8;\\n                slugSelectorIndex++\\n            ) {\\n                selectorIndex++;\\n\\n                if (selectorIndex > l.selectorCount) {\\n                    break;\\n                }\\n\\n                bytes4 selector = bytes4(slug << (slugSelectorIndex << 5));\\n                address facet = address(bytes20(l.selectorInfo[selector]));\\n\\n                bool continueLoop;\\n\\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                    if (diamondFacets[facetIndex].target == facet) {\\n                        diamondFacets[facetIndex].selectors[\\n                            numFacetSelectors[facetIndex]\\n                        ] = selector;\\n                        // probably will never have more than 256 functions from one facet contract\\n                        require(numFacetSelectors[facetIndex] < 255);\\n                        numFacetSelectors[facetIndex]++;\\n                        continueLoop = true;\\n                        break;\\n                    }\\n                }\\n\\n                if (continueLoop) {\\n                    continue;\\n                }\\n\\n                diamondFacets[numFacets].target = facet;\\n                diamondFacets[numFacets].selectors = new bytes4[](\\n                    l.selectorCount\\n                );\\n                diamondFacets[numFacets].selectors[0] = selector;\\n                numFacetSelectors[numFacets] = 1;\\n                numFacets++;\\n            }\\n        }\\n\\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n            uint256 numSelectors = numFacetSelectors[facetIndex];\\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\\n\\n            // setting the number of selectors\\n            assembly {\\n                mstore(selectors, numSelectors)\\n            }\\n        }\\n\\n        // setting the number of facets\\n        assembly {\\n            mstore(diamondFacets, numFacets)\\n        }\\n    }\\n\\n    /**\\n     * @notice get all selectors for given facet address\\n     * @param facet address of facet to query\\n     * @return selectors array of function selectors\\n     */\\n    function _facetFunctionSelectors(\\n        address facet\\n    ) internal view returns (bytes4[] memory selectors) {\\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\\n\\n        // initialize array with maximum possible required length\\n        // it will be truncated to correct length via assembly later\\n        selectors = new bytes4[](l.selectorCount);\\n\\n        uint256 numSelectors;\\n        uint256 selectorIndex;\\n\\n        // loop through function selectors\\n        for (uint256 slugIndex; selectorIndex < l.selectorCount; slugIndex++) {\\n            bytes32 slug = l.selectorSlugs[slugIndex];\\n\\n            for (\\n                uint256 slugSelectorIndex;\\n                slugSelectorIndex < 8;\\n                slugSelectorIndex++\\n            ) {\\n                selectorIndex++;\\n\\n                if (selectorIndex > l.selectorCount) {\\n                    break;\\n                }\\n\\n                bytes4 selector = bytes4(slug << (slugSelectorIndex << 5));\\n\\n                if (facet == address(bytes20(l.selectorInfo[selector]))) {\\n                    selectors[numSelectors] = selector;\\n                    numSelectors++;\\n                }\\n            }\\n        }\\n\\n        // set the number of selectors in the array\\n        assembly {\\n            mstore(selectors, numSelectors)\\n        }\\n    }\\n\\n    /**\\n     * @notice get addresses of all facets used by diamond\\n     * @return addresses array of facet addresses\\n     */\\n    function _facetAddresses()\\n        internal\\n        view\\n        returns (address[] memory addresses)\\n    {\\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\\n\\n        addresses = new address[](l.selectorCount);\\n        uint256 numFacets;\\n        uint256 selectorIndex;\\n\\n        for (uint256 slugIndex; selectorIndex < l.selectorCount; slugIndex++) {\\n            bytes32 slug = l.selectorSlugs[slugIndex];\\n\\n            for (\\n                uint256 slugSelectorIndex;\\n                slugSelectorIndex < 8;\\n                slugSelectorIndex++\\n            ) {\\n                selectorIndex++;\\n\\n                if (selectorIndex > l.selectorCount) {\\n                    break;\\n                }\\n\\n                bytes4 selector = bytes4(slug << (slugSelectorIndex << 5));\\n                address facet = address(bytes20(l.selectorInfo[selector]));\\n\\n                bool continueLoop;\\n\\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                    if (facet == addresses[facetIndex]) {\\n                        continueLoop = true;\\n                        break;\\n                    }\\n                }\\n\\n                if (continueLoop) {\\n                    continue;\\n                }\\n\\n                addresses[numFacets] = facet;\\n                numFacets++;\\n            }\\n        }\\n\\n        // set the number of facet addresses in the array\\n        assembly {\\n            mstore(addresses, numFacets)\\n        }\\n    }\\n\\n    /**\\n     * @notice get the address of the facet associated with given selector\\n     * @param selector function selector to query\\n     * @return facet facet address (zero address if not found)\\n     */\\n    function _facetAddress(\\n        bytes4 selector\\n    ) internal view returns (address facet) {\\n        facet = address(\\n            bytes20(DiamondBaseStorage.layout().selectorInfo[selector])\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC2535DiamondLoupe } from '../../../interfaces/IERC2535DiamondLoupe.sol';\\nimport { IDiamondReadableInternal } from './IDiamondReadableInternal.sol';\\n\\n/**\\n * @title Diamond proxy introspection interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IDiamondReadable is IERC2535DiamondLoupe, IDiamondReadableInternal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\\n */\\nlibrary DiamondBaseStorage {\\n    struct Layout {\\n        // function selector => (facet address, selector slug position)\\n        mapping(bytes4 => bytes32) selectorInfo;\\n        // total number of selectors registered\\n        uint16 selectorCount;\\n        // array of 32-byte slugs with 8 selectors each\\n        mapping(uint256 => bytes32) selectorSlugs;\\n        address fallbackAddress;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.DiamondBase');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/fallback/IDiamondFallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IDiamondBase } from '../base/IDiamondBase.sol';\\n\\ninterface IDiamondFallback is IDiamondBase {\\n    /**\\n     * @notice query the address of the fallback implementation\\n     * @return fallbackAddress address of fallback implementation\\n     */\\n    function getFallbackAddress()\\n        external\\n        view\\n        returns (address fallbackAddress);\\n\\n    /**\\n     * @notice set the address of the fallback implementation\\n     * @param fallbackAddress address of fallback implementation\\n     */\\n    function setFallbackAddress(address fallbackAddress) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/base/IDiamondBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IProxy } from '../../IProxy.sol';\\n\\ninterface IDiamondBase is IProxy {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { AddressUtils } from '../utils/AddressUtils.sol';\\nimport { IProxy } from './IProxy.sol';\\n\\n/**\\n * @title Base proxy contract\\n */\\nabstract contract Proxy is IProxy {\\n    using AddressUtils for address;\\n\\n    /**\\n     * @notice delegate all calls to implementation contract\\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\\n     * @dev memory location in use by assembly may be unsafe in other contexts\\n     */\\n    fallback() external payable virtual {\\n        address implementation = _getImplementation();\\n\\n        if (!implementation.isContract())\\n            revert Proxy__ImplementationIsNotContract();\\n\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                implementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice get logic implementation address\\n     * @return implementation address\\n     */\\n    function _getImplementation() internal virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/ISafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IOwnable } from './IOwnable.sol';\\nimport { ISafeOwnableInternal } from './ISafeOwnableInternal.sol';\\n\\ninterface ISafeOwnable is ISafeOwnableInternal, IOwnable {\\n    /**\\n     * @notice get the nominated owner who has permission to call acceptOwnership\\n     */\\n    function nomineeOwner() external view returns (address);\\n\\n    /**\\n     * @notice accept transfer of contract ownership\\n     */\\n    function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nlibrary ERC165BaseStorage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC165Base');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\\n    /**\\n     * @notice indicates whether an interface is already supported based on the interfaceId\\n     * @param interfaceId id of interface to check\\n     * @return bool indicating whether interface is supported\\n     */\\n    function _supportsInterface(\\n        bytes4 interfaceId\\n    ) internal view virtual returns (bool) {\\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @notice sets status of interface support\\n     * @param interfaceId id of interface to set status for\\n     * @param status boolean indicating whether interface will be set as supported\\n     */\\n    function _setSupportsInterface(\\n        bytes4 interfaceId,\\n        bool status\\n    ) internal virtual {\\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/IERC165Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\\n\\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC2535DiamondLoupeInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC2535 read interface for internal functions\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IERC2535DiamondLoupeInternal {\\n    struct Facet {\\n        address target;\\n        bytes4[] selectors;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC2535DiamondCutInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC2535 write interface for internal functions\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IERC2535DiamondCutInternal {\\n    enum FacetCutAction {\\n        ADD,\\n        REPLACE,\\n        REMOVE\\n    }\\n\\n    struct FacetCut {\\n        address target;\\n        FacetCutAction action;\\n        bytes4[] selectors;\\n    }\\n\\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC173Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title Partial ERC173 interface needed by internal functions\\n */\\ninterface IERC173Internal {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC165Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC165 interface registration interface\\n */\\ninterface IERC165Internal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/SafeOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { ISafeOwnableInternal } from './ISafeOwnableInternal.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\\n\\nabstract contract SafeOwnableInternal is ISafeOwnableInternal, OwnableInternal {\\n    modifier onlyNomineeOwner() {\\n        if (msg.sender != _nomineeOwner())\\n            revert SafeOwnable__NotNomineeOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @notice get the nominated owner who has permission to call acceptOwnership\\n     */\\n    function _nomineeOwner() internal view virtual returns (address) {\\n        return SafeOwnableStorage.layout().nomineeOwner;\\n    }\\n\\n    /**\\n     * @notice accept transfer of contract ownership\\n     */\\n    function _acceptOwnership() internal virtual {\\n        _setOwner(msg.sender);\\n        delete SafeOwnableStorage.layout().nomineeOwner;\\n    }\\n\\n    /**\\n     * @notice grant permission to given address to claim contract ownership\\n     */\\n    function _transferOwnership(address account) internal virtual override {\\n        _setNomineeOwner(account);\\n    }\\n\\n    /**\\n     * @notice set nominee owner\\n     */\\n    function _setNomineeOwner(address account) internal virtual {\\n        SafeOwnableStorage.layout().nomineeOwner = account;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC173 } from '../../interfaces/IERC173.sol';\\nimport { IOwnableInternal } from './IOwnableInternal.sol';\\n\\ninterface IOwnable is IOwnableInternal, IERC173 {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/writable/IDiamondWritableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC2535DiamondCutInternal } from '../../../interfaces/IERC2535DiamondCutInternal.sol';\\n\\ninterface IDiamondWritableInternal is IERC2535DiamondCutInternal {\\n    error DiamondWritable__InvalidInitializationParameters();\\n    error DiamondWritable__RemoveTargetNotZeroAddress();\\n    error DiamondWritable__ReplaceTargetIsIdentical();\\n    error DiamondWritable__SelectorAlreadyAdded();\\n    error DiamondWritable__SelectorIsImmutable();\\n    error DiamondWritable__SelectorNotFound();\\n    error DiamondWritable__SelectorNotSpecified();\\n    error DiamondWritable__TargetHasNoCode();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value > address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/readable/IDiamondReadableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC2535DiamondLoupeInternal } from '../../../interfaces/IERC2535DiamondLoupeInternal.sol';\\n\\n/**\\n * @title Diamond proxy introspection interface needed for internal functions\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IDiamondReadableInternal is IERC2535DiamondLoupeInternal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/IProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\ninterface IProxy {\\n    error Proxy__ImplementationIsNotContract();\\n\\n    fallback() external payable;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\\n\\ninterface IERC165BaseInternal is IERC165Internal {\\n    error ERC165Base__InvalidInterfaceId();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/SafeOwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nlibrary SafeOwnableStorage {\\n    struct Layout {\\n        address nomineeOwner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.SafeOwnable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/ISafeOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IOwnableInternal } from './IOwnableInternal.sol';\\n\\ninterface ISafeOwnableInternal is IOwnableInternal {\\n    error SafeOwnable__NotNomineeOwner();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/IOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IERC173Internal } from '../../interfaces/IERC173Internal.sol';\\n\\ninterface IOwnableInternal is IERC173Internal {\\n    error Ownable__NotOwner();\\n    error Ownable__NotTransitiveOwner();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/UintUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientPadding();\\n    error UintUtils__InvalidBase();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    /**\\n     * @notice output the string representation of a number in a given radix\\n     * @dev radix must be between 2 and 36 (inclusive)\\n     * @param value number to format as string\\n     * @param radix numerical base to use\\n     * @return output formatted string\\n     */\\n    function toString(\\n        uint256 value,\\n        uint256 radix\\n    ) internal pure returns (string memory output) {\\n        // this check is repeated in the internal call to #toString(uint256,uint256,uint256)\\n        // but is still needed here to avoid zero division (radix = 0) or infinite loop (radix = 1)\\n        if (radix < 2) {\\n            revert UintUtils__InvalidBase();\\n        }\\n\\n        uint256 length;\\n        uint256 temp = value;\\n\\n        do {\\n            unchecked {\\n                length++;\\n            }\\n            temp /= radix;\\n        } while (temp != 0);\\n\\n        output = toString(value, radix, length);\\n    }\\n\\n    /**\\n     * @notice output the string representation of a number in a given radix and padded to given length\\n     * @dev radix must be between 2 and 36 (inclusive)\\n     * @param value number to format as string\\n     * @param radix numerical base to use\\n     * @param length size to which output should be zero padded\\n     * @return output formatted string\\n     */\\n    function toString(\\n        uint256 value,\\n        uint256 radix,\\n        uint256 length\\n    ) internal pure returns (string memory output) {\\n        if (radix < 2 || radix > 36) {\\n            revert UintUtils__InvalidBase();\\n        }\\n\\n        bytes memory buffer = new bytes(length);\\n\\n        while (length != 0) {\\n            unchecked {\\n                length--;\\n            }\\n\\n            uint256 char = value % radix;\\n\\n            if (char < 10) {\\n                // for numeral characters, shift 48 places through ASCII character set\\n                // 48 can be added using bitwise-or because its binary is 00110000\\n                char |= 48;\\n            } else {\\n                // for alphabetical characters, shift 87 places through ASCII character set\\n                unchecked {\\n                    char += 87;\\n                }\\n            }\\n\\n            buffer[length] = bytes1(uint8(char));\\n            value /= radix;\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientPadding();\\n\\n        output = string(buffer);\\n    }\\n\\n    /**\\n     * @notice output the 0b-prefixed binary string representation of a number\\n     * @param value number to format as string\\n     * @return output formatted string\\n     */\\n    function toBinString(\\n        uint256 value\\n    ) internal pure returns (string memory output) {\\n        uint256 length;\\n        uint256 temp = value;\\n\\n        do {\\n            unchecked {\\n                length++;\\n            }\\n            temp >>= 1;\\n        } while (temp != 0);\\n\\n        output = toBinString(value, length);\\n    }\\n\\n    /**\\n     * @notice output the 0b-prefixed binary string representation of a number padded to given length\\n     * @param value number to format as string\\n     * @param length size to which output should be zero padded (not including prefix)\\n     * @return output formatted string\\n     */\\n    function toBinString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory output) {\\n        // add two to length for the leading \\\"0b\\\"\\n        length += 2;\\n\\n        bytes memory buffer = new bytes(length);\\n        buffer[0] = '0';\\n        buffer[1] = 'b';\\n\\n        while (length > 2) {\\n            unchecked {\\n                length--;\\n            }\\n\\n            buffer[length] = HEX_SYMBOLS[value & 1];\\n            value >>= 1;\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientPadding();\\n\\n        output = string(buffer);\\n    }\\n\\n    /**\\n     * @notice output the 0o-prefixed octal string representation of a number\\n     * @param value number to format as string\\n     * @return output formatted string\\n     */\\n    function toOctString(\\n        uint256 value\\n    ) internal pure returns (string memory output) {\\n        uint256 length;\\n        uint256 temp = value;\\n\\n        do {\\n            unchecked {\\n                length++;\\n            }\\n            temp >>= 3;\\n        } while (temp != 0);\\n\\n        output = toOctString(value, length);\\n    }\\n\\n    /**\\n     * @notice output the 0o-prefixed octal string representation of a number padded to given length\\n     * @param value number to format as string\\n     * @param length size to which output should be zero padded (not including prefix)\\n     * @return output formatted string\\n     */\\n    function toOctString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory output) {\\n        // add two to length for the leading \\\"0o\\\"\\n        length += 2;\\n\\n        bytes memory buffer = new bytes(length);\\n        buffer[0] = '0';\\n        buffer[1] = 'o';\\n\\n        while (length > 2) {\\n            unchecked {\\n                length--;\\n            }\\n\\n            buffer[length] = HEX_SYMBOLS[value & 7];\\n            value >>= 3;\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientPadding();\\n\\n        output = string(buffer);\\n    }\\n\\n    /**\\n     * @notice output the decimal string representation of a number\\n     * @param value number to format as string\\n     * @return output formatted string\\n     */\\n    function toDecString(\\n        uint256 value\\n    ) internal pure returns (string memory output) {\\n        output = toString(value, 10);\\n    }\\n\\n    /**\\n     * @notice output the decimal string representation of a number padded to given length\\n     * @param value number to format as string\\n     * @param length size to which output should be zero padded\\n     * @return output formatted string\\n     */\\n    function toDecString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory output) {\\n        output = toString(value, 10, length);\\n    }\\n\\n    /**\\n     * @notice output the 0x-prefixed hexadecimal string representation of a number\\n     * @dev calculated string length will always be even to prevent splitting of bytes\\n     * @param value number to format as string\\n     * @return output formatted string\\n     */\\n    function toHexString(\\n        uint256 value\\n    ) internal pure returns (string memory output) {\\n        uint256 length;\\n        uint256 temp = value;\\n\\n        do {\\n            unchecked {\\n                length++;\\n            }\\n            temp >>= 8;\\n        } while (temp != 0);\\n\\n        output = toHexString(value, length);\\n    }\\n\\n    /**\\n     * @notice output the 0x-prefixed hexadecimal string representation of a number padded to given length\\n     * @dev calculated string length will always be even to prevent splitting of bytes\\n     * @param value number to format as string\\n     * @param length size (in bytes) to which output should be zero padded (not including prefix)\\n     * @return output formatted string\\n     */\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory output) {\\n        // convert byte length to character length and add two to length for the leading \\\"0x\\\"\\n        unchecked {\\n            length = (length << 1) + 2;\\n        }\\n\\n        bytes memory buffer = new bytes(length);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        while (length > 2) {\\n            unchecked {\\n                length--;\\n            }\\n\\n            buffer[length] = HEX_SYMBOLS[value & 15];\\n            value >>= 4;\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientPadding();\\n\\n        output = string(buffer);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": []\r\n  }\r\n}}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_utilityCoDiamond\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DiamondWritable__InvalidInitializationParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__RemoveTargetNotZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__ReplaceTargetIsIdentical\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorIsImmutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorNotSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__TargetHasNoCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC165Base__InvalidInterfaceId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotTransitiveOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Proxy__ImplementationIsNotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeOwnable__NotNomineeOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IERC2535DiamondCutInternal.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IERC2535DiamondCutInternal.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IERC2535DiamondCutInternal.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IERC2535DiamondCutInternal.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IERC2535DiamondLoupeInternal.Facet[]\",\"name\":\"diamondFacets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFallbackAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fallbackAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUtilityCoDiamond\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nomineeOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fallbackAddress\",\"type\":\"address\"}],\"name\":\"setFallbackAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "RENSNCEDAODMND",
      "CompilerVersion": "v0.8.30+commit.73712a01",
      "CompilerType": "solc-j",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "000000000000000000000000d0311895aa4c9200d1f239e7c35fc8282da52ec2",
      "EVMVersion": "Default",
      "Library": "",
      "ContractFileName": "blockscout-verified/84532/0xDA146e3A30BC3d4f3Bf23b374EfE21650ceD01C9/contracts/RENSNCEDAODMND.sol",
      "LicenseType": "",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "",
      "SimilarMatch": ""
    }
  ]
}